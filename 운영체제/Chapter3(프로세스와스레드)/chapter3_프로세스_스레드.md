# CS10/04 (chap03.)

1. **프로그램 & 프로세스**
- 프로그램은 프로세스와 다르다. 프로그램은 저장장치에 정적 저장되어 있음.
- 프로세스는 저장장치에 있는 프로그램이 실행을 위해서 메모리에 올라온 상태이다.
- 당연히 메모리는 저장장치보다 용량이 작다. 따라서 적절히 그 공간을 활용할 필요가 있다.

1. **프로세스의 상태**
- 생성 상태: 메모리에서 프로그램을 가져옴
- 준비 상태: CPU의 자원을 할당받기 위한 준비상태, 프로세스를 CPU스케쥴러가 관리
- 실행 상태: 간택받은 프로세스가 CPU를 사용하는 상태이다.
- (대기 상태): 실행 상태에 있던 프로레스가 입력이나 출력이 있으면 완료될 때까지 기다리는 상태이다. 입출력이 완료되면 실행상태로 가는 것이 아니라 준비 상태로 간다.
- 완료상태: 프로세스가 말그대로 종료된 상태. 데이터 소각.

1. **PCB(프로세스 제어 블록)**
- 모든 프로세스는 자신의 PCB를 갖는데 프로세스의 상태나 태스크 등 CPU가 프로세스를 관리할 정보가 들어가 있다.
    - 포인터: 첫번째 블록에 저장. 준비상태나 대기 상태의 큐를 구현할 때 포인터 사용.
    - 프로세스 구분자: 운영체제 내에 있는 여러 프로세스 구별하기 위한 구분자.
    - 프로그램 카운터: 다음 실행될 명령어의 위치 가르킴.
    - 프로세스 우선순위: 각각의 중요도 대로 구현된 큐.
    - 메모리 관련 정보: 프로세스가 메모리의 어디에 있는지 나타내는 위치 정보.

1. **문맥 교환**
- 복수의 프로세스의 정보를 교환하는 작업. 한 프로세스의 작업이 끝나거나 대기상태로 가서 다른 프로세스를 불러올 때 발생. 각각의 프로세스에서 다른 프로세스로의 작업 이동할 때 작업 환경 또한 바꾸는 것. (ex 요리사가 다른 주문서의 요리를 할 때 발생)

1. **fork()와 exec() 시스템 호출**
- fork() - 실행 중인 프로세스를 복사하는 함수 (github에서 레포 포크하는 것과 비슷)
    - ex) 같은 요리를 여러 손님이 주문 했을 때 하나만 만들고 나머진 복사해서 주는 것
    - 크롬에서 ctrl + N 했을 때 그 브라우저의 탭을 그대로 가진 창 하나를 더 만듦.
    - 하지만 프로세스의 구분자는 역시 다르다.
- exec() - 기존의 프로세스를 새로운 프로세스로 전환하는 함수.
    - fork()가 요리를 복제한다면 exec()는 그 요리를 다른 요리로 바꾸는 것이다.
    - 왜씀? 프로세스 다시 만들려면  PCB도 만들고 메모리 자리도 또 확보해야함.
    - 이미 만들어진 프로세스의 구조를 재활용하는 것이다.

1. **프로세스의 계층 구조**
- 부모 프로세스를 복사 - 자식프로세스를 만드는데 이때 형성되는 상하구조.
    - init()의 자식
    - login 프로세스 - 인증을 거쳐 컴퓨터에 접속하는 과정 처리 사용자가 많으면 그 만큼 login프로세스를 fork()를 뜬다.
    - shell프로세스 - 로그인된 사용자가 운영체제에 명령을 내리고 결과 받을 수 있게 하는 프로세스
    - login 에서 shell 프로세스로 갈 때 지우고 다시 만드는 것이 아니라 exec() 시스템 호출로 바꾼다.
- 자신의 자원을 자식에게 상속하고 자식 프로세스가 완료되면 자원 회수.
    - 운영체제가 직접 자원을 회수할 필요가 없어져서 편하다.

1. **스레드**
- CPU스케쥴러가 CPU에 전달하는 하나의 일 단위.
    - 프로세스가 해야할 일은 CPU가 한다.
- 여러 스레드가 하나의 프로세스 안에 포함되어 있을 수 있다.
    - 주문서 하나를 프로세스라 한다면 그 주문서의 요리의 레시피대로 요리를 실제로 만드는 일을 스레드라고 할 수 있다.
- 프로세스 끼리는 약한 연결 스레드끼리는 강한 연결
    - ex 스테이크와 케이크는 약하지만 스테이크를 만들기 위한 레시피의 순서 등은 영향이 크다.

1. **스레드 관련**
- 멀티스레드: 하나의 프로세스 작업을 여러 개의 스레드로 분할하여 작업의 부담을 줄이는 방식
- 멀티태스킹: 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법
    - 이러한 시분할 시스템에서 CPU에 전달하는 작업은 프로세스가 아니라 스레드이다.
- 멀티프로세싱: CPU를 여러 개 사용하여 여러 개의 스레드를 같이 처리하는 방식
    - 시분할로 빠르게 하나씩 하는 것이 아니라 진짜 동시에 처리
- CPU 멀티스레드: 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법이다.
    - 파이프 라인 기법: 큐처럼 한번에 하나씩 뽑아내서 처리하는 기법.
    - 그냥 멀티스레드와 다른 점은 하드웨어적인 방법으로 하나의 CPU에서 여러 스레드 동시에 처리하는 기법이다.

1. **멀티스레드의 특징(장점)**
- 응답성 향상: 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있다.
- 자원 공유: 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원할하게 진행할 수 있다.
- 효율성 향상: 불필요한 자원의 중복을 막음으로써 시스템의 효율이 향상된다.
- 다중 CPU 지원: 멀티 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 여러 개의 CPU가 멀티스레드를 동시에 처리하여 CPU사용량이 증가 → 프로세스의 처리 시간이 단축된다.

9-1. **멀티스레드 단점**

- 하나의 프로세스 안에 여러 스레드를 돌리고 있기 때문에 강한 연결을 가진 스레드의 특징 때문에 하나의 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.

1. **멀티스레드 모델**
- 사용자 레벨 스레드: 사용자 레벨에서 관련 라이브러리를 사용하여 구현하며, 라이브러리는 커널이 지원하는 스케줄링이나 동기화 같은 기능을 대신 구현해준다.(1 to N)
    - 운영체제가 멀티스레드를 지원하지 않을 때 사용하는 방법. 초기의 스레드 시스템에서 이용
    - 커널이 하는 일을 라이브러리가 대신 처리하여 여러 개의 스레드를 작동한다.
    - 하지만 결국 커널의 스레드 하나와 연결된다.
    - 라이브러리가 직접 스케줄링하고 처리하기 때문에 문맥 교환이 필요 없다.
    - 보안에 취약하다.
- 커널 레벨 스레드: 커널이 멀티스레드를 지원하는 방식이다.( 1 to 1)
    - 하나의 사용자 스레드가 하나의 커널 스레드와 연결
    - 스레드끼리 영향이 줄어든다.
    - 문맥 교환이 필요하기 때문에 사용자 레벨 스레드보다 느릴 수 있다.
- 멀티레벨 스레드: 사용자 레벨 스레드와 커널 레벨 스레드를 혼합한 방식으로 하이브리드 스레드라고도 한다.( M to N )
    - 빠르게 움직여야 하는 스레드는 사용자 레벨 스레드로 작동
    - 안정적으로 움직여야 하는 스레드는 커널 레벨 스레드로 작동한다.