# CHAPTER 06 교착상태

1. 교착 상태의 개요
2. 교착 상태 필요 조건
3. 교착 상태 해결 방법
4. 다중 자원과 교착 상태 검출

## 01. 교착 상태의 개요

### 1). 교착 상태의 정의

![Untitled](Chapter6/Untitled.png)

2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태

여러 프로세스가 작업을 진행하다 보면 자연적으로 발생 → 발생시 강압적으로 해결해야 함.

### 2). 교착 상태의 발생

시스템 자원

공유 변수

![Untitled](Chapter6/Untitled%201.png)

응용 프로그램

![Untitled](Chapter6/Untitled%202.png)

### 3). 자원 할당 그래프

프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 표현

![Untitled](Chapter6/Untitled%203.png)

![Untitled](Chapter6/Untitled%204.png)

식사하는 철학자 문제 

![Untitled](Chapter6/Untitled%205.png)

식사하는 철학자 문제에서 교착 상태가 발생하는 조건

- 철학자들은 포크를 공유할 수 없다. → 자원을 공유하지 못하면 교착 상태가 발생
- 각 철학자는 다른 철학자의 포크를 빼앗을 수 없다. → 자원을 빼앗을 수 없으면 기다려야 하므로 교착 상태가 발생
- 각 철학자는 왼쪽 포크를 잡은 채 오른쪽 포크를 기다린다. → 자원 하나를 잡은 상태에서 다른 자원을 기다리면 교착 상태가 발생
- 자원 할당 그래프가 원형이다 → 자원을 요구하는 방향이 원을 이루면 양보를 하지 않기 때문에 교착 상태가 발생

## 02. 교착 상태 필요조건

### 1). 교착 상태 필요조건

- 상호 배제 (mutual exclusion)

한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다.

배타적인 자원은 임계 구역으로 보호되기 때문에 다른 프로세스가 동시에 사용할 수 없다.

- 비선점 (non-preemption)

한 프로세스가 사용하는 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다.

- 점유와 대기 (hold and wait)

프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태여야 한다.

- 원형 대기 (circular)

점유와 대기를 하는 프로세스 간의 관계가 원을 이루어야 한다.

위 조건을 모두 충족해야 교착상태가 발생한다. 이 중 단 하나라도 충족하지 않으면 발생하지 않는다.

## 03. 교착 상태 해결 방법

### 1). 교착 상태 해결 방법

- 교착 상태 예방 - 교착 상태를 유발하는 네 가지 조건을 무력화한다.
- 교착 상태 회피 - 교착 상태가 발생하지 않는 수준으로 자원을 할당한다.
- 교착 상태 검출 - 자원 할당 그래프를 사용하여 교착 상태를 발견한다.
- 교착 상태 회복 - 교착 상태를 검출한 후 해결한다.

### 2). 교착 상태 예방

상호 배제 예방

독점적으로 사용할 수 있는 자원을 없애버리는 방법

시스템 내에는 공유할 수 없는 자원이 있기 때문에 무력화하는 것은 사실상 어렵다.

비선점 예방

모든 자원을 빼앗을 수 있도록 만드는 방법

임계 구역을 보호하기 위해 잠금을 사용하면 빼앗을 수 없을 뿐만 아니라 상호 배제도 보장할 수 없다.

점유와 대기 예방

프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법

프로세스는 시작 초기에 자신이 사용하는 모든 자원을 한꺼번에 점유하거나, 그렇지 못한 경우 자원을 모두 반납해야 한다.

단점

- 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다.
- 자원의 활용성이 떨어진다.
- 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리하다.
- 결국 일괄 작업 방식으로 작동한다.

![Untitled](Chapter6/Untitled%206.png)

원형 대기 예방

점유와 대기를 하는 프로세스들이 원형을 이루지 못하도록 막는 방법

자원을 한 방향으로만 사용하도록 설정함으로써 원형 대기를 예방

![Untitled](Chapter6/Untitled%207.png)

단점

- 프로세스 작업 진행에 유연성이 떨어진다.
- 자원의 번호를 어떻게 부여할 것인지가 문제이다.

자원을 보호하기 위해 상호 배제와 비선점을 예방하기 어려우며 점유와 대기, 원형 대기는 프로세스 작업 방식을 제한하고 자원을 낭비한다.

### 3). 교착 상태 회피

자원을 할당할 때 어느 수준 이상의 자원을 나누어주면 교착 상태가 발생하는지 파악하여 그 수준 이하로 자원을 나누어 주는 방법

![Untitled](Chapter6/Untitled%208.png)

은행원 알고리즘

최악의 경우를 기준으로 문제 상황을 철저히 피하여 교착 상태를 막는다.

| 변수 | 설명 |
| --- | --- |
| 전체 자원 | 시스탬 내 전체 자원의 수 |
| 가용 자원 | 시스탬 내 현재 사용할 수 있는 자원의 수 (가용 자원 = 전체 자원 - 모든 프로세스에 할당 자원)  |
| 최대 자원 | 각 프로세스가 선언한 최대 자원의 수 |
| 할당 자원 | 각 프로세스에 할당된 자원의 수 |
| 기대 자원 | 각 프로세스가 앞으로 사용할 자원의 수(기대 자원 = 최대 자원 - 할당 자원) |
- 각 프로세스의 기대 자원과 비교하여 가용 자원이 하나라도 크거나 같으면 자원을 할당한다. 가용 자원이 기대 자원보다 크다는 것은 그 자원을 사용하여 작업을 끝낼 수 있는 프로세스가 있다는 의미이므로 안정 상태이다.
- 가용 자원이 어떤 기대 자원보다 크지 않으면 할당하지 않는다. 가용 자원을 사용하여 작업을 마칠 수 있는 프로세스가 없다는 의미이므로 불안정 상태이다.

안정 상태 : 각 프로세스의 기대 자원과 비교하여 가용 자원이 크거나 같은 경우가 한 번 이상인 경우

![Untitled](Chapter6/Untitled%209.png)

교착 상태 회피의 문제점

- 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.
- 시스템의 전체 자원 수가 고정적이어야 한다.
- 자원이 낭비된다.

### 4). 교착 상태 검출

교착 상태 해결 방법 중 가장 현실적인 방법

운영체제가 프로세스의 작업을 관찰하면서 교착 상태 발생 여부를 주시하는 방식

교착 상태가 발견되면 교착 상태 회복 단계를 밟는다.

타임아웃을 이용한 교착 상태 검출

![Untitled](Chapter6/Untitled%2010.png)

단점

- 엉뚱한 프로세스가 강제 종료될 수 있다.
- 모든 시스템에 적용할 수 없다.

데이터베이스에서 체크포인트와 롤백으로 사용

자원 할당 그래프를 아용한 교착 상태 검출

![Untitled](Chapter6/Untitled%2011.png)

자원 할당 그래프를 유지, 갱신, 사이클을 검사하는 추가 작업으로 오버헤드 발생

### 5). 교착 상태 회복

교착 상태를 유발한 프로세스를 강제로 종료 후 실행되기 전에 시스템을 복구

- 교착 상태를 일으킨 모든 프로세스를 동시에 종료
- 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료 (우선순위가 낮음 → 작업 시간이 짧음 → 자원을 많이 사용함)

## 04. 다중 자원과 교착 상태 검출

![Untitled](Chapter6/Untitled%2012.png)

대기 그래프 : 자원 할당 그래프에서 프로세스와 프로세스 간에 기다리는 관계만 나타낸 그래프

그래프 감소 : 대기 그래프에서 작업이 끝날 가능성이 있는 프로세스의 화살표와 관련 프로세스의 화살표를 연속적으로 지워가는 작업

![Untitled](Chapter6/Untitled%2013.png)

![Untitled](Chapter6/Untitled%2014.png)

# DB에서의 교착 상태

## 예방 기법

대표적인 예방 기법은 아래와 같다.

- 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 Lock(잠금)한다.
    - 필요한 모든 데이터를 Lock(잠금)해야 하므로 병행성이 떨어진다.
- SET LOCK_TIMEOUT문을 통해 일정 시간이 지나면 쿼리를 취소한다.
    - 기존의 교착상태인 데이터가 있다면, 그 데이터에 접근하는 쿼리만 취소한다.
    - 즉, 근본적인 해결책이 될 수 없다.

## 회피 기법

**회피 기법은 자원을 할당할 때 시간 스탬프(Time Stamp)를 활용해서 교착상태가 일어나지 않도록 회피하는 방법**이다. 예방 기법의 단점 때문에 실제로는 회피 기법이 많이 사용된다.

회피 기법의 종류는 크게 2가지가 있다.

- Wait-Die 방식
    - 트랜잭션 A가 트랜잭션 B에 의해 잠금된 데이터를 요청할 때 트랜잭션 A이 먼저 들어온 트랜잭션이라면 대기(Wait)한다.
    - 트랜잭션 A가 나중에 들어온 트랜잭션이라면, 포기(Die)하고 나중에 다시 요청한다.
- Wound-Wait 방식
    - 트랜잭션 A가 트랜잭션 B보다 먼저 들어온 트랜잭션이라면, 데이터를 선점(Wound)한다.
    - 반면, 트랜잭션A가 트랜잭션 B보다 나중에 들어온 트랜잭션이라면 대기(Wait)한다.

## 낙관적 병행 제어 기법

낙관적 병행 제어 기법은 트랜잭션이 실행되는 동안에는 검사를 수행하지 않고, 트랜잭션이 커밋된 후에 데이터에 문제가 있다면 롤백(Rollback)하는 방법이다.

즉, 낙관적 병행 제어 기법은 **판독->확인->기록** 단계를 따른다. **확인 단계**를 성공적으로 거친 트랜잭션만  **기록 단계**를 수행할 수 있다.

## 빈도 줄이기

교착상태의 빈도를 낮추는 방법은 아래와 같다.

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. (위에서는 트랜잭션 1은 B->A 순, 트랜잭션 2는 A->B순으로 접근했다.)
- 읽기 잠금 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 테이블 단위의 Lock(잠금)을 획득해 갱신을 직렬화한다. (테이블의 복수행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 자주 발생하기 때문)
- Index 설계 (Update시 Index를 타지 않으면 테이블 전체에 Lock이 걸릴 수 있다.)
- Isolation level(고립 수준)을 낮춘다. (서비스 검토 필요)
