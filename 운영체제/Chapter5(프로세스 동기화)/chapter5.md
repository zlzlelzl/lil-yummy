# 운영체제 스터디

---

# Chapter5. 프로세스 동기화

## 1. 프로세스간 통신의 개념

> 프로세스는 시스템 내에서 독립적으로 실행되기도 하고 다른 프로세스 혹은
네트워크로 연결된 다른 컴퓨터의 프로세스와 데이터를 주고받으며 협업하기도 한다.
> 

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled.png)

- 프로세스 내부 데이터 통신
    - 하나의 프로세스 내 2개 이상의 `스레드`가 존재할 때 발생가능한 통신
    - 스레드간 전역 변수, 파일을 통한 데이터 교환
- 프로세스 간 데이터 통신
    - 같은 컴퓨터 내 다수의 프로세스간 통신
    - 공용파일, 운영체제가 제공하는 파이프 기반 통신
- 네트워크를 이용한 데이터 통신
    - 다수의 컴퓨터가 네트워크로 연결되어 있을 때, `소켓`을 이용한 데이터 교환
    - `소켓`을 이용한 통신은 `네트워킹`이라고도 부른다.
    - 다른 컴퓨터의 함술 호출하여 통신하는 원격 프로시저 호출도 이에 해당한다.

<aside>
💡 통신 방식을 결정하는 경우는 대개 `**오버헤드**`를 고려한다.

같은 컴퓨터에 있는 프로세스끼리도 localhost와 같은 루프백 주소를 사용해서 통신이 가능하지만 다른 프로세스간 통신보다 속도가 떨어지기 때문에 소켓을 거의 사용하지 않는다.

</aside>

---

## 2. 프로세스 간 통신의 분류

### 2.1 통신 방향에 따른 분류

> 통신은 데이터가 전송되는 방향에 따라 양방향 통신, 반양방향 통신, 단방향 통신으로 나뉜다.
> 

- 양방향 통신
    - 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조
    - 일반적인 통신의 형태
    - 소켓을 통한 통신이 양방향 통신에 해당된다.
- 반양방향 통신
    - 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 
    특정 시점에 한쪽 방향으로만 전송할 수 있는 구조
    - 대표적인 예시로는 무전기
- 단방향 통신
    - 모스 신호처럼 한쪽 방향으로만 데이터를 전송할 수 있는 구조
    - 전역 변수와 파이프를 통한 통신이 단방향 통신이다.
    
    <aside>
    💡 전역변수의 경우에는 접근 시 기존 값이 지워지므로 전역변수 2개를 
    사용하지 않는 이상 단방향 통신으로 볼 수 있다.
    
    </aside>
    

### 2.2 통신 구현 방식에 따른 분류

- Busy waiting(바쁜 대기) 문제
    - 전역변수를 사용하는 방식에서는 언제 데이터를 보낼지 모르기 때문에 
    주기적으로 전역변수의 값을 점검해야 함.
    - 이를 극복하고자 나타난 것이 동기화

프로세스 간 통신은 동기화 기능의 존재 여부에 따라 두가지로 구분이 된다.

- `동기화 통신` (대기가 있는 통신)
    - 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머무른다.
    - 파이프, 소켓을 통한 통신이 해당
- `비동기화 통신` (대기가 없는 통신)
    - 데이터를 받는 쪽은 바쁜 대기를 사용하여 주기적으로 데이터 도착여부를 확인한다.
    - 전역 변수, 파일을 통한 통신이 해당
    - 보내는 쪽과 받는 쪽의 동기화는 수행되지 않는다.
    - 오버헤드가 적지만 사용자가 직접 처리해야 하는 작업이 많다.

---

## 3. 통신에 따른 연산

### 3.1 전역 변수를 이용한 통신

공동으로관리하는 메모리를 사용하여 데이터를 주고받는다.

주로 직접적으로 관련이 있는 프로세스간에 사용한다. (부모-자식 프로세스)

- send
    - 전역변수나 파일에 값을 쓴다.
- receive
    - 전역변수의 값을 읽는다.

```c
// 부모 프로세스와 자식 프로세스가 공유하는 메모리 영역
// 해당 변수를 쓰거나 읽음으로 두 프로세스가 통신한다.
int GV; 

int main()
{
	int pid;
	pid=fork();
}
```

두 전역변수 L, R을 생성하여 fork 후 프로세스를 들어 수행 시 동작하는 연산

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled%201.png)

동기화 방식

### 3.2 파일을 이용한 통신

크게 세 가지 부분으로 구성되어 있다.

- 열기(open)
- 쓰기 & 읽기(write & read)
- 닫기(close)

```c
int main()
{
	int fd;
	char buf[5];

	fd = open("com.txt", O_RDWR);
	write(fd, "test", 5);
	read(fd, buf, 5);
	close(fd);
	exit(0);
}
```

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled%202.png)

다음과 같은 과정이 이루어진다.

1. 프로세스에서 쓰기 요구
2. 데이터 저장
3. 입력 요구
4. 입출력 프로세스에서 데이터 가져오기

<aside>
💡 통상적으로 파일을 이용한 통신은 부모-자식 관계의 통신에서 자주 발생하며 운영체제가 
프로세스 동기화를 제공하지 않는다.

이 경우, 부모 프로세스가 자식프로세스가 끝나기 전까지 wait()함수를 이용하여 기다렸다가 작업을 시작한다.

</aside>

### 3.3. 파이프를 이용한 통신

> 운영체제가 제공하는 동기화 방식
전역 변수를 이용한 통신과 마찬가지로 `단방향 통신`이다.
양방향 필요시 추가적인 파이프를 운용하여 2개를 사용해야한다
> 

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled%203.png)

- 프로세스 B가 파이프 1에 대해 읽기 연산 수행
    - 프로세스 A가 쓰기연산을 하지 않았다면 `대기상태` 돌입
    - 프로세스 A가 쓰기연산 수행 시, 대기상태 해제 및 `동기화`

파이프 크게 두가지로 나뉜다.

- `이름없는 파이프`
    - 일반적으로 칭하는 파이프
    - 부모-자식 프로세스와 같은 서로 관련있는 프로세스간 통신에 사용된다.
- `이름있는 파이프`
    - FIFO라 불리는 특수 파일을 이용하여 서로 관련없는 프로세스간 통신에 사용된다.

<aside>
💡 파이프 2개를 통한 동기화 방식을 통해
프로세스 B는 비동기식의 바쁜 대기를 하지 않아도 된다.

</aside>

### 3.4. 소켓을 이용한 통신

> 통신 필요시, 자신의 소켓과 상대의 소켓을 연결(바인딩)
소켓에 쓰기연산 시 데이터 전송
읽기 연산 시 데이터 수신
> 

---

# 2. 공유 자원과 임계 구역

## 1. 공유 자원의 접근

> 공유 자원(shared resource)은 여러 프로세스가 공동으로 이용하는 
변수, 메모리, 파일 등을 일컫는다.
> 

전역변수의 문제

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled%204.png)

예시와 같이 프로세스간의 작업이 갈리면서 전역변수의 값이 상이해지는 현상 발생,

위와같은 상황을 `경쟁조건` 이 발생했다고 한다.

## 2. 임계 구역

> 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역(전역변수 등)을 
`임계구역`이라고 한다.
> 

![                      자원 관리에 대한 현실적인 예시 
                      (민초넣고 자바칩 같이 갈지말자)](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled%205.png)

                      자원 관리에 대한 현실적인 예시 
                      (민초넣고 자바칩 같이 갈지말자)

<aside>
💡 `임계구역` 내에서 프로세스들은 동시에 작업해서는 안된다.

한 프로세스가 `임계구역`에 들어갈 경우 다른 프로세스는 `임계구역` 밖에서 기다려야 하며
들어간 프로세스가 나와야 들어갈 수 있다.

</aside>

## 3. 생산자-소비자 문제

> 생산자 프로세스와 소비자 프로세스가 서로 독립적인 작업을 수행한다.
생산자는 `buffer`에 넣고(input(buf)) 소비자는 `buffer`에서 데이터를 가져온다(output(buf))
작업을 이어나가기 위해서는 `circular buffer`가 사용되며
버퍼가 가득 찼는지를 알기 위해 `sum`이라는 이름의 전역변수를 사용한다.
> 

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled%206.png)

여기서 문제 발생

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled%207.png)

## 4. 임계 구역 해결 조건

임계 구역 문제를 해결하는 방법은 다음 세가지 조건을 만족해야한다.

- 상호 배제 (mutual exclusion)
    - 한 프로세스가 `임계구역`에 들어가면 다른 프로세스는 들어갈 수 없다.
- 한정 대기 (bounded waiting)
    - 어떤 프로세스도 무한정으로 대기할 수는 없다.
    - 특정 프로세스가 `임계구역`에 진입하지 못하면 안된다.
- 진행의 융통성 (progress flexibillity)
    - `임계구역`이 비어있을 때는 언제든지 프로세스가 진입할 수 있다.
    - 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다.

# 3. 임계 구역 해결 방법

> `임계구역` 문제를 해결하는 단순한 방법은 잠금을 이용하는 것이다.
> 

## 1. 코드 소개

```c
#include <stdio.h>

typedef enum {flase, true} boolean;
extern boolean lock = false;
extern int balance;

main(){
	while(lock==true);
	lock=true;
	balance=balance+10;
	lock=false;
}
```

위의 코드 2개를 두고 분석

- 임계구역은 한 순간에 한 프로세스만 접근 가능
- 프로세스가 공유하는 변수는 `공유변수`
- 임계구역으로 보호되어야 할 부분은 `임계구역`

## 2. 임계구역 해결 조건을 고려한 코드 설계

### 2.1. 상호 배제 문제

앞서 작성한 코드를 두개로 늘렸을 때 각각 p1, p2라고 둔다.

- lock의 초기값은 `false`
- `false` 는 잠금이 해제되었다는 의미

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled%208.png)

1. lock이 `true` 일 경우 임계 구역의 프로세스는 무한정 대기 while(lock==true);
2. lock이 false일 경우 lock을 true로 전환시키고 임계구역 내에서 프로세스는 동작수행
3. 수행 후 다시 lock를 false로 바꾼다.

하지만 여기서 문제가 발생하게 된다.

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20b64bb53518744ee4b283d94cdadb2dc8/Untitled%209.png)

임계구역이 비어있는 상태 `false` 일 경우, 다음과 같은 과정이 수행된다 가정해보자.

1. p1이 (while(lock==true);)를 수행한다.
임계구역이 비어있기 때문에 무한루프 종료, 하지만 cpu시간을 다 써서(타임아웃) 
임계구역에 진입한 상태에서 준비상태로 옮겨진다.
이후 문맥 교환이 이루어지고 프로세스 p2가 실행 상태로 전환
2. 프로세스 p2가 while lock == true; 문을 실행하고, 임계구역 진입
3. 프로세스 p1도 임계 구역에 위치, 프로세스 p2도 임계구역에 위치

상호배제를 제거한 상태에서

위와 같은 과정이 수행 될 경우 잠금이 풀리