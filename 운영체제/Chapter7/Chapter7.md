# CS10/13(chap07.)

# Chapter 07. 물리 메모리 관리

---

1. 메모리 관리의 개요
2. 메모리 주소
3. 단일 프로그래밍 환경에서의 메모리 할당
4. 다중 프로그래밍 환경에서의 메모리 할당

## 1. 메모리 관리의 개요

---

1. **메모리 관리의 복잡성**

- 메모리에는 주소로 구분되는 영역들이 있다. CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)을 사용한다.
- 오늘날의 시분할 시스템에서는 운영체제를 포함한 모든 응용프로그램이 메모리에 올라오기 때문에 관리가 복잡하다.

![재료가 하나의 프로그램이라 한다면 시분할 시스템에서는 모든 재료가 도마위에 올라와 있다.](Chapter7/1.png)

재료가 하나의 프로그램이라 한다면 시분할 시스템에서는 모든 재료가 도마위에 올라와 있다.

1. **메모리 관리의 이중성**

- 프로세스의 입장에서는 메모리를 독차지 하고 싶어하고, 메모리 관지라의 입장에서는 효율적으로 메모리를 관리하고 싶어한다. 이것이 상충되며 이중성이라 한다.

1. **소스코드의 번역과 실행**

- 컴파일러와 인터프리터
  - 컴파일러는 소스코드를 전체적으로 목적언어( 1,0)으로 변환시킨다. 그 과정에서 오류 제거와 최적화 등을 실행한다. 컴파일러를 거쳐야 실행할 수 있기 때문에 과정이 복잡할 수 있다. 대표적으로 자바가 여기에 속해있다.
  - 인터프리터는 소스코드를 한 행씩 번역하며 실행한다. 실행이 편리하지만 속도가 느릴 수 있다. 대표적으로 자바스크립트가 이 언어에 속한다.
  ![Untitled](Chapter7/Untitled.png)
- 컴파일 과정
  - 컴파일은 사용자가 작성한 소스코드를 목적 코드로 변환한 후 라비으러리를 연결하고 최종 실행파일을 만들어 실행하는 과정이다.
  ![Untitled](Chapter7/Untitled%201.png)

1. **메모리 관리자의 역할**

   ![Untitled](Chapter7/Untitled%202.png)

- 가져오기(fetch)
  - 프로세스와 데이터를 메모리로 가져오는 작업 메모리보다 가져오는 용량이 더 크다면 일부만 가져와서 실행하고 부분부분 필요할 때마다 가져온다.
- 배치(placement)
  - 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다. 2가지가 있는데 고정적으로 메모리를 분할하는 paging과 프로세스에 맞게 자르는 segmentation이 있다.
- 재배치(replacement)
  - 메모리가 꽉 찼다면 오래된 프로세스를 내보내는 작업

## 2. 메모리 주소

---

1. **32bit와 64bit CPU**

- 한번에 다룰 수 있는 데이터의 최대 크기를 의미한다.
- 메모리의 주소 범위도 2의 거듭제곱으로 정해지므로 32bit는 2의 32제곱만큼의 최대 메모리 범위(약 4GB)를 가진다. 63bit는 무한대와 가까운 최대 메모리 범위를 가진다(약 1600백만TB)
- 물리주소 공간은 하드웨어 입장에서 바라본 주소공간이다.
- 논리주소 공간은 사용자의 입장에서 바라본 주소공간이다.

![Untitled](Chapter7/Untitled%203.png)

1. **절대주소와 상대주소**

- 메모리는 운영체제 영역과 사용자 영역이 엄격하게 분리되어 있다. 따라서 사용자 영역에서 사용하는 메모리는 운영체제 영역을 침범할 수 없는데, 이때 사용되는 개념이 절대주소와 상대주소이다.

![Untitled](Chapter7/Untitled%204.png)

- 절대주소는 말 그대로 절대적인 그 주소를 말한다. 이 그림에선 운영체제의 절대주소 영역은 0~360까지고 사용자 영역은 361부터 999까지이다.
- 따라서 사용자가 운영체제 영역을 침범하지 않고 사용하기 위해선 항상 운영체제의 영역을 확인해야 하는 번거로움이 있다.
- 이럴 때 상대주소가 쓰이는데 사용자는 운영체제의 영역을 상관하지 않고 항상 0번지부터 시작한다. 그리고 실제로는 그 상대주소 + 운영체제의 범위(360)을 더한 주소를 절대주소로 변환 후 사용한다.
- 이 변환 과정에서 메모리 관리자는 재배치 레지스터를 사용한다.

## 3.단일 프로그래밍 환경에서의 메모리 할당

---

1. **메모리 오버레이**

- 예전 컴퓨터의 메모리는 640KB 수준이었다. 이렇게 작은 메모리에서 큰 용량의 프로그램을 운영하려면 어쩔 수 없이 하나의 프로그램을 여러개로 나눠야 한다.
- 이 때 여러개의 모듈로 나눠서 상황에 필요한 모듈만 꺼내서 메모리에 올린다.

![Untitled](Chapter7/Untitled%205.png)

1. **스왑**

- 여러 모듈로 나눴을 때 발생하는 문제가 안쓰는 모듈을 어디에 저장할지가 문제이다.
- 이럴 때 다시 하드에 넣지 않고 별도의 임시 공간에 넣는데 이것이 스왑 영역이다. 스왑 영역은 저장장치의 특별한 공간에 있다.
- 스왑영역에 넣을때 swap out, 거기서 다시 메모리로 가져올 때 swap in이라고 한다.
- 이렇게 되면 실제 사용자가 인식하는 메모리의 크기는 실제 메모리의 크기 + 스왑의 크기이다.

![Untitled](Chapter7/Untitled%206.png)

## 4.다중 프로그래밍 환경에서의 메모리 할당

---

1. **메모리 분할 방식**

![Untitled](Chapter7/Untitled%207.png)

- 가변 분할 방식: 프로세스의 크기에 따라 메모리는 나누는 것(segmentation)
  - 가변 분할 방식은 프로세스가 들어오는 대로 메모리를 그 크기에 맞춰서 분할한다. 따라서 메모리들이 연속적으로 할당되고 하나의 프로세스가 나누어 지지 않고 통째로 들어간다.
  - 장점은 프로세스들이 분할되지 않고 메모리에 올라간다.
  - 단점은 작은 프로세스들이 들어갔다 메모리에서 나왔을 때 생기는 작은 구간이 있을 수 있다. 따라서 그보다 큰 프로세스가 들어올 때 다른 프로세스들을 옮겨서 자리를 확보해야하는 불편함이 있다. (외부 단편화)
  - 이렇게 작은 공간들을 다시 통합하는 과정을 조각모음이라고 한다.

![Untitled](Chapter7/Untitled%208.png)

![Untitled](Chapter7/Untitled%209.png)

- 고정 분할 방식: 프로세스의 크기와 상관없이 메모리르 같은 크기로 나누는 것이다.(paging)
  - 고정 분할 방식은 일정한 단위 크기에 맞게 메모리를 분할 시키기 때문에 프로세스들이 같은 공간을 점유한다. 다만 그 단위보다 큰 프로세스는 분할하여 메모리에 올린다.
  - 장점은 메모리 관리가 수월하며, 가변 분할 방식의 메모리 통합같은 작업을 할 필요가 없다.
  - 단점은 쓸모없는 공간이 생겨서 메모리가 낭비가 발생할 수 있다.(내부 단편화)

![Untitled](Chapter7/Untitled%2010.png)

![Untitled](Chapter7/Untitled%2011.png)

1. **메모리 배치 방식**

- 최초 배치: 최초 배치는 단편화를 고려하지 않는 것, 가장 먼저 보이는 공간에 프로세스 배치
- 최적배치: 메모리의 빈 공간을 모두 확인한 후 가장 작은 적당한 공간에 프로세스 배치
- 최악배치: 메모리의 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스 배치

![Untitled](Chapter7/Untitled%2012.png)

1. **버디 시스템**

- 가변 분할 방식의 단점인 외부 단편화를 완화하는 방법으로 버디 시스템이 있다. 약간 짬뽕 너낌.
- 작동 방식
  - 프로세스의 크기에 맞게 메모리를 1/2로 계속 자르고 프로세스 배치.
  - 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어감.
  - 프로세스가 종료되면 주변의 빈 조각과 합친다.

![Untitled](Chapter7/Untitled%2013.png)

- 특징은 가변 분할 방식과 달리 후에 메모리 통합이 수월하다. 왜냐하면 계속 1/2로 나누기 때문에 작은 프로세스들은 뒤쪽에 몰려 있기 때문에 중간 중간에 땜빵 났을 경우 여러 프로세스들이 움직여야 하는데 그럴 필요가 없다.
